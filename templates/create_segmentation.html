<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Create Segmentation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <style>
    :root {
      /* Light theme variables */
      --bg-primary: #f8f9fa;
      --bg-secondary: #ffffff;
      --text-primary: #212529;
      --text-secondary: #6c757d;
      --border-color: #dee2e6;
      --accent-color: #0d6efd;
      --accent-hover: #0b5ed7;
      --panel-bg: #f1f1f1;
      --canvas-border: #ccc;
      --slider-bg: #e9ecef;
      --tool-hover: #e9ecef;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    [data-theme="dark"] {
      /* Dark theme variables */
      --bg-primary: #212529;
      --bg-secondary: #343a40;
      --text-primary: #f8f9fa;
      --text-secondary: #adb5bd;
      --border-color: #495057;
      --accent-color: #0d6efd;
      --accent-hover: #3385ff;
      --panel-bg: #343a40;
      --canvas-border: #495057;
      --slider-bg: #495057;
      --tool-hover: #495057;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      transition: background-color 0.3s, color 0.3s;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    /* Main content area */
    .main-content {
      flex-grow: 1;
      padding: 20px;
      overflow: auto;
      display: flex;
      flex-direction: column;
    }

    /* Canvas container */
    .canvas-container {
      border: 2px solid var(--canvas-border);
      border-radius: 8px;
      background-color: var(--bg-secondary);
      margin-bottom: 20px;
      flex-grow: 1;
      position: relative;
      overflow: hidden;
      box-shadow: var(--box-shadow);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Relationship panel */
    .relationship-panel {
      background-color: var(--bg-secondary);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: var(--box-shadow);
    }

    .relationship-panel h3 {
      margin-top: 0;
      color: var(--text-primary);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
      margin-bottom: 15px;
    }

    .relationship-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background-color: var(--panel-bg);
      overflow-y: auto;
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
    }

    /* Header with theme toggle */
    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background-color: var(--accent-color);
      color: white;
    }

    .theme-toggle {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .theme-toggle i {
      margin-right: 8px;
    }

    /* Panel styling */
    .panel {
      border-bottom: 1px solid var(--border-color);
      padding: 15px;
    }

    .panel-title {
      font-weight: 600;
      margin: 0 0 15px 0;
      color: var(--text-primary);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-title i {
      cursor: pointer;
      transition: transform 0.3s;
    }

    .panel-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    /* Tool buttons */
    .tool-btn {
      display: flex;
      align-items: center;
      width: 100%;
      padding: 10px 12px;
      background-color: var(--accent-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }

    .tool-btn:hover {
      background-color: var(--accent-hover);
    }

    .tool-btn i {
      margin-right: 8px;
    }

    .tool-btn.secondary {
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    .tool-btn.secondary:hover {
      background-color: var(--tool-hover);
    }

    /* Tool grid */
    .tool-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    /* Form controls */
    .control-group {
      margin-bottom: 15px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-primary);
    }

    input[type="file"] {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
    }

    select, input[type="text"], textarea {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--bg-secondary);
      color: var(--text-primary);
    }

    /* Sliders */
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .slider-container label {
      min-width: 100px;
      margin-bottom: 0;
    }

    input[type="range"] {
      flex-grow: 1;
      height: 6px;
      border-radius: 3px;
      background-color: var(--slider-bg);
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: var(--accent-color);
      cursor: pointer;
    }

    /* Color picker */
    .color-picker {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .color-picker label {
      min-width: 100px;
      margin-bottom: 0;
    }

    input[type="color"] {
      -webkit-appearance: none;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 4px;
      background: none;
      cursor: pointer;
    }

    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    input[type="color"]::-webkit-color-swatch {
      border: 1px solid var(--border-color);
      border-radius: 4px;
    }

    /* Collapsible panels */
    .collapsed .panel-content {
      display: none;
    }

    .collapsed .panel-title i {
      transform: rotate(-90deg);
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      
      .sidebar {
        width: 100%;
        height: auto;
        max-height: 300px;
        border-left: none;
        border-top: 1px solid var(--border-color);
      }
    }
  </style>
</head>
<body>
  <div class="editor-header">
    <h1>Advanced Image Editor</h1>
    <div class="theme-toggle" onclick="toggleTheme()">
      <i class="fas fa-moon"></i>
      <span>Dark Mode</span>
    </div>
  </div>

  <div class="container">
    <div class="main-content">
      <div class="canvas-container">
        <canvas id="canvas" width="800" height="600"></canvas>
      </div>

      <div class="relationship-panel">
        <h3>Define Relationships</h3>
        <div class="relationship-controls">
          <select id="object1" class="form-select">
            <option value="">Select Object 1</option>
          </select>
          <select id="relationshipType" class="form-select">
            <option value="connected">Connected to</option>
            <option value="contains">Contains</option>
            <option value="partOf">Part of</option>
          </select>
          <select id="object2" class="form-select">
            <option value="">Select Object 2</option>
          </select>
          <button class="tool-btn" onclick="addRelationship()">
            <i class="fas fa-link"></i> Add Relationship
          </button>
        </div>
      </div>

      <button class="tool-btn" onclick="generateJSON()">
        <i class="fas fa-code"></i> Generate JSON
      </button>
      <div id="jsonContainer" class="mt-3"></div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <h3 class="panel-title">
          Basic Tools <i class="fas fa-chevron-down"></i>
        </h3>
        <div class="panel-content">
          <div class="tool-grid">
            <button class="tool-btn" onclick="clearCanvas()">
              <i class="fas fa-trash"></i> Clear
            </button>
            <button class="tool-btn" onclick="addRectangle()">
              <i class="fas fa-square"></i> Rectangle
            </button>
            <button class="tool-btn" onclick="addCircle()">
              <i class="fas fa-circle"></i> Circle
            </button>
            <button class="tool-btn" onclick="addLine()">
              <i class="fas fa-slash"></i> Line
            </button>
          </div>
          <button class="tool-btn secondary" onclick="removeSelectedObject()">
            <i class="fas fa-times"></i> Remove Selected
          </button>
        </div>
      </div>

      <div class="panel">
        <h3 class="panel-title">
          Layer Management <i class="fas fa-chevron-down"></i>
        </h3>
        <div class="panel-content">
          <button class="tool-btn" onclick="addLayer()">
            <i class="fas fa-plus"></i> Add Layer
          </button>
          <button class="tool-btn secondary" onclick="removeLayer()">
            <i class="fas fa-minus"></i> Remove Layer
          </button>
          <button class="tool-btn secondary" onclick="renameLayer()">
            <i class="fas fa-pen"></i> Rename Layer
          </button>
          <div class="tool-grid">
            <button class="tool-btn secondary" onclick="lockLayer()">
              <i class="fas fa-lock"></i> Lock
            </button>
            <button class="tool-btn secondary" onclick="unlockLayer()">
              <i class="fas fa-unlock"></i> Unlock
            </button>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3 class="panel-title">
          Image Tools <i class="fas fa-chevron-down"></i>
        </h3>
        <div class="panel-content">
          <div class="control-group">
            <input type="file" id="imageUpload" accept="image/*" class="form-control" />
            <button class="tool-btn" onclick="addImage()">
              <i class="fas fa-image"></i> Add Image
            </button>
          </div>
          <div class="control-group">
            <input type="file" id="segmentImageUpload" accept="image/*" class="form-control" />
            <button class="tool-btn" onclick="sendImageForSegmentation()">
              <i class="fas fa-cut"></i> Segment Image
            </button>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3 class="panel-title">
          Adjustments <i class="fas fa-chevron-down"></i>
        </h3>
        <div class="panel-content">
          <div class="color-picker">
            <label>Color:</label>
            <input type="color" id="colorPicker" onchange="changeColor()" />
          </div>
          
          <div class="slider-container">
            <label>Opacity:</label>
            <input type="range" id="opacitySlider" min="0" max="1" step="0.1" value="1" onchange="changeOpacity()" />
            <span id="opacityValue">100%</span>
          </div>
          
          <div class="slider-container">
            <label>Brightness:</label>
            <input type="range" id="brightnessSlider" min="0" max="200" value="100" onchange="adjustBrightness()" />
            <span id="brightnessValue">100%</span>
          </div>
          
          <div class="slider-container">
            <label>Contrast:</label>
            <input type="range" id="contrastSlider" min="0" max="200" value="100" onchange="adjustContrast()" />
            <span id="contrastValue">100%</span>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3 class="panel-title">
          Arrangement <i class="fas fa-chevron-down"></i>
        </h3>
        <div class="panel-content">
          <div class="tool-grid">
            <button class="tool-btn secondary" onclick="bringForward()">
              <i class="fas fa-arrow-up"></i> Forward
            </button>
            <button class="tool-btn secondary" onclick="sendBackward()">
              <i class="fas fa-arrow-down"></i> Backward
            </button>
            <button class="tool-btn secondary" onclick="bringToFront()">
              <i class="fas fa-level-up-alt"></i> To Front
            </button>
            <button class="tool-btn secondary" onclick="sendToBack()">
              <i class="fas fa-level-down-alt"></i> To Back
            </button>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3 class="panel-title">
          AI Image Generation <i class="fas fa-chevron-down"></i>
        </h3>
        <div class="panel-content">
          <form id="imageForm">
            <div class="control-group">
              <textarea id="imagePrompt" placeholder="Enter your prompt here" rows="3" name="prompt"></textarea>
              <button class="tool-btn" type="submit">
                <i class="fas fa-magic"></i> Generate Image
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
  <script>
    
      // Theme toggling functionality
      function toggleTheme() {
        const body = document.body;
        const themeToggle = document.querySelector('.theme-toggle');
        const icon = themeToggle.querySelector('i');
        const text = themeToggle.querySelector('span');
        
        if (body.getAttribute('data-theme') === 'dark') {
          body.removeAttribute('data-theme');
          icon.classList.remove('fa-sun');
          icon.classList.add('fa-moon');
          text.textContent = 'Dark Mode';
        } else {
          body.setAttribute('data-theme', 'dark');
          icon.classList.remove('fa-moon');
          icon.classList.add('fa-sun');
          text.textContent = 'Light Mode';
        }
      }
  
      // Panel collapsing functionality
      const panels = document.querySelectorAll('.panel');
      panels.forEach(panel => {
        const title = panel.querySelector('.panel-title');
        title.addEventListener('click', () => {
          panel.classList.toggle('collapsed');
        });
      });
  
      // Update slider value displays
      document.getElementById('opacitySlider').addEventListener('input', function() {
        document.getElementById('opacityValue').textContent = `${Math.round(this.value * 100)}%`;
      });
  
      document.getElementById('brightnessSlider').addEventListener('input', function() {
        document.getElementById('brightnessValue').textContent = `${this.value}%`;
      });
  
      document.getElementById('contrastSlider').addEventListener('input', function() {
        document.getElementById('contrastValue').textContent = `${this.value}%`;
      });
    let canvas = new fabric.Canvas("canvas");
    let relationships = [];
    let layers = [];
    let layerCount = 0;
    let currentLayer = null;
    let lockedLayers = [];

    function showPopup(message) {
      const popup = document.getElementById("popup");
      popup.innerText = message;
      popup.style.display = "block";
      setTimeout(() => {
        popup.style.display = "none";
      }, 2000);
    }

    // Layer Management Functions
    function addLayer() {
      layerCount++;
      const layerName = `Layer ${layerCount}`;
      layers.push({ name: layerName, objects: [] });
      currentLayer = layers.length - 1; // set to current layer
      showPopup(`${layerName} added`);
    }

    function removeLayer() {
      if (currentLayer !== null && layers[currentLayer]) {
        const removedLayer = layers.splice(currentLayer, 1);
        showPopup(`${removedLayer[0].name} removed`);
        currentLayer = layers.length - 1; // Set the last one as current
      }
    }

    function renameLayer() {
      if (currentLayer !== null && layers[currentLayer]) {
        const newName = prompt("Enter new layer name ");
        layers[currentLayer].name = newName;
        showPopup(`Layer renamed to ${newName}`);
      }
    }

    function lockLayer() {
      if (currentLayer !== null && layers[currentLayer]) {
        lockedLayers.push(layers[currentLayer].name);

        // Loop through objects in the current layer and make them non-selectable
        layers[currentLayer].objects.forEach((obj) => {
          obj.selectable = false;
          obj.evented = false; // Prevent object interaction
        });

        canvas.renderAll(); // Re-render the canvas
        showPopup(`${layers[currentLayer].name} locked`);
      }
    }

    // Unlock the current layer, making objects in the layer selectable again
    function unlockLayer() {
      if (currentLayer !== null && layers[currentLayer]) {
        const index = lockedLayers.indexOf(layers[currentLayer].name);
        if (index !== -1) {
          lockedLayers.splice(index, 1);

          // Loop through objects in the current layer and make them selectable
          layers[currentLayer].objects.forEach((obj) => {
            obj.selectable = true;
            obj.evented = true; // Allow object interaction
          });

          canvas.renderAll(); // Re-render the canvas
          showPopup(`${layers[currentLayer].name} unlocked`);
        }
      }
    }

    // Add objects to layer with layer locking checks
    function addObjectToLayer(object) {
      if (!isLayerLocked() && layers[currentLayer]) {
        layers[currentLayer].objects.push(object);
        updateObjectSelects();
      } else {
        showPopup(
          `${layers[currentLayer].name} is locked or no active layer selected!`
        );
      }
    }

    // Check if the current layer is locked
    function isLayerLocked() {
      return lockedLayers.includes(layers[currentLayer]?.name);
    }

    // Add objects to layer
    function addObjectToLayer(object) {
      if (!isLayerLocked() && layers[currentLayer]) {
        layers[currentLayer].objects.push(object);
        updateObjectSelects();
      } else {
        showPopup(
          `${layers[currentLayer].name} is locked or no active layer selected!`
        );
      }
    }

    // Brightness and Contrast Adjustment
    function adjustBrightness() {
      const brightness = document.getElementById("brightnessSlider").value;
      const activeObject = canvas.getActiveObject();
      if (activeObject && activeObject.filters) {
        activeObject.filters[0] = new fabric.Image.filters.Brightness({
          brightness: brightness / 100,
        });
        activeObject.applyFilters();
        canvas.renderAll();
      }
    }

    function adjustContrast() {
      const contrast = document.getElementById("contrastSlider").value;
      const activeObject = canvas.getActiveObject();
      if (activeObject && activeObject.filters) {
        activeObject.filters[1] = new fabric.Image.filters.Contrast({
          contrast: contrast / 100,
        });
        activeObject.applyFilters();
        canvas.renderAll();
      }
    }

    // Add Image to canvas
    function addImage() {
      const input = document.getElementById("imageUpload");
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        fabric.Image.fromURL(e.target.result, function (img) {
          canvas.add(img);
          addObjectToLayer(img);
        });
      };
      reader.readAsDataURL(file);
    }

    // Add a shape to the canvas
    function addRectangle() {
      const rect = new fabric.Rect({
        left: 100,
        top: 100,
        fill: "#ff0000",
        width: 100,
        height: 100,
        selectable: true,
      });
      canvas.add(rect);
      addObjectToLayer(rect);
    }

    function addCircle() {
      const circle = new fabric.Circle({
        left: 200,
        top: 200,
        fill: "#00ff00",
        radius: 50,
        selectable: true,
      });
      canvas.add(circle);
      addObjectToLayer(circle);
    }

    function addLine() {
      const line = new fabric.Line([50, 50, 200, 200], {
        left: 50,
        top: 50,
        stroke: "#000000",
        selectable: true,
      });
      canvas.add(line);
      addObjectToLayer(line);
    }

    function removeSelectedObject() {
      const selectedObject = canvas.getActiveObject();
      if (selectedObject) {
        canvas.remove(selectedObject);
      }
    }

    function bringForward() {
      const selectedObject = canvas.getActiveObject();
      if (selectedObject) {
        canvas.bringForward(selectedObject);
      }
    }

    function sendBackward() {
      const selectedObject = canvas.getActiveObject();
      if (selectedObject) {
        canvas.sendBackwards(selectedObject);
      }
    }

    function bringToFront() {
      const selectedObject = canvas.getActiveObject();
      if (selectedObject) {
        canvas.bringToFront(selectedObject);
      }
    }

    function sendToBack() {
      const selectedObject = canvas.getActiveObject();
      if (selectedObject) {
        canvas.sendToBack(selectedObject);
      }
    }

    function changeColor() {
      const color = document.getElementById("colorPicker").value;
      const activeObject = canvas.getActiveObject();
      if (activeObject) {
        activeObject.set({ fill: color });
        canvas.renderAll();
      }
    }

    // Update object select dropdown
    function updateObjectSelects() {
      const object1Select = document.getElementById("object1");
      const object2Select = document.getElementById("object2");
      object1Select.innerHTML = "";
      object2Select.innerHTML = "";

      layers.forEach((layer) => {
        layer.objects.forEach((object, index) => {
          const option = document.createElement("option");
          option.value = index;
          option.textContent = `${ layer.name } - ${ object.type }`;
          object1Select.appendChild(option);
          object2Select.appendChild(option);
        });
      });
    }

    // Define Relationships between objects
    function addRelationship() {
      const object1Index = document.getElementById("object1").value;
      const object2Index = document.getElementById("object2").value;
      const relationshipType =
        document.getElementById("relationshipType").value;

      if (object1Index && object2Index) {
        relationships.push({
          object1: layers[currentLayer].objects[object1Index],
          object2: layers[currentLayer].objects[object2Index],
          relationshipType: relationshipType,
        });
        showPopup("Relationship added!");
      }
    }

    // Generate JSON for the canvas
    function generateJSON() {
      const canvasJSON = canvas.toJSON();
      const jsonContainer = document.getElementById("jsonContainer");
      jsonContainer.innerText = JSON.stringify(canvasJSON, null, 2);
    }

    function generateImage() {
      const prompt = document.getElementById("imagePrompt").value;

      if (!prompt.trim()) {
        showPopup("Please enter a prompt for image generation.");
        return;
      }

      // Start timing the image generation process
      const startTime = performance.now();

      // Sending a POST request to the backend with the prompt
      fetch("/generate-image", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ prompt }),
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error("Failed to generate image.");
          }
          return response.json();
        })
        .then((data) => {
          console.log("Generated Image Data:", data); // Debug response data

          if (data && data.image_url) {
            const imageUrl = data.image_url; // The URL of the generated image

            // Create a new draggable image element
            const imgElement = new Image();
            imgElement.src = imageUrl;
            imgElement.id = "generated-image";
            imgElement.draggable = true; // Make it draggable
            imgElement.style = `
                    width: 150px; 
                    cursor: grab; 
                    margin-top: 10px;
                    border: 1px solid #ccc;
                    border-radius: 5px;
                `;

            // Append the image to the sidebar or another container
            const sidebar = document.getElementById("sidebar");
            sidebar.appendChild(imgElement);

            // Add dragstart event listener to pass the image URL
            imgElement.addEventListener("dragstart", (e) => {
              e.dataTransfer.setData("text/plain", imageUrl);
              showPopup("Drag the image to the canvas!");
            });
          } else {
            throw new Error("Image URL not returned from backend.");
          }

          // End timing and log the duration
          const endTime = performance.now();
          const duration = endTime - startTime;
          console.log("Image generated in `${ duration.toFixed(2) }` ms.");
        })
        .catch((error) => {
          console.error("Error generating image:", error);
          showPopup("Error generating image: " + error.message);

          // End timing and log the error duration (even if it's an error)
          const endTime = performance.now();
          const duration = endTime - startTime;
          console.log("Image generation failed after ${ duration.toFixed(2) } ms.");
        });
    }

    async function sendImageForSegmentation(isMultiPoint = false) {
      const input = document.getElementById("imageUpload");
      if (!input.files[0]) {
        showPopup("Please upload an image first");
        return;
      }

      const formData = new FormData();
      formData.append("image", input.files[0]);

      const endpoint = isMultiPoint ? '/segment-points' : '/segment';
      const body = isMultiPoint ? {
        points: clickPoints,
        image: canvas.toDataURL()
      } : formData;

      try {
        const response = await fetch(endpoint, {
          method: 'POST',
          body: isMultiPoint ? JSON.stringify(body) : body,
          headers: isMultiPoint ? {
            'Content-Type': 'application/json'
          } : undefined
        });

        if (!response.ok) throw new Error('Segmentation failed');

        const data = await response.json();
        if (data.segmented_image) {
          const img = new Image();
          img.src = `data:image/png;base64,${data.segmented_image}`;
          img.onload = () => {
            const fabricImage = new fabric.Image(img);
            canvas.add(fabricImage);
            canvas.renderAll();
            clickPoints = [];  // Reset points after segmentation
          };
        }
      } catch (error) {
        console.error("Segmentation error:", error);
        showPopup("Error: " + error.message);
      }
    }
    let clickPoints = [];
    let segmentationMode = true;

    canvas.on('mouse:down', function (options) {
      if (segmentationMode) {
        const pointer = canvas.getPointer(options.e);
        clickPoints.push([pointer.x, pointer.y]);

        // Draw point marker
        const circle = new fabric.Circle({
          left: pointer.x - 5,
          top: pointer.y - 5,
          radius: 5,
          fill: 'red',
          selectable: false
        });
        canvas.add(circle);
      }
    });
    function clearCanvas() {
      canvas.clear();
    }
  </>
</body>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }

  h1 {
    color: #333;
  }

  form {
    margin-bottom: 20px;
  }

  input,
  button {
    padding: 10px;
    font-size: 16px;
  }

  button {
    background-color: #007bff;
    color: white;
    border: none;
    cursor: pointer;
  }

  button:hover {
    background-color: #0056b3;
  }

  #result img {
    display: block;
    margin-top: 20px;
    max-width: 100%;
    border: 1px solid #ddd;
    border-radius: 5px;
    box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.1);
  }

  #result p {
    color: red;
  }
</style>
</head>

<body>
  <h1>Image Generation with Hugging Face API</h1>
  <div id="result"></div>

  <script>
    document.getElementById("imageForm").addEventListener("submit", async (e) => {
      e.preventDefault();

      const form = e.target;
      const formData = new FormData(form);
      const resultDiv = document.getElementById("result");

      // Clear previous results
      resultDiv.innerHTML = "";

      try {
        const response = await fetch("/generate-image", {
          method: "POST",
          body: formData,
        });

        if (response.ok) {
          const data = await response.json();
          const img = document.createElement("img");
          img.src = data.image_url;
          img.alt = "Generated Image";
          img.style = "width: 150px; cursor: grab; margin-top: 10px;"; // Style to indicate it's draggable

          // Make the generated image draggable
          img.draggable = true;

          // Add dragstart event listener to set data for dragging
          img.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData("text/plain", img.src);
            showPopup("Drag the image to the canvas!");
          });

          resultDiv.appendChild(img);

          // Enable the image to be moved to the canvas when dropped
          const canvasContainer = document.getElementById("canvas-container");

          canvasContainer.addEventListener("dragover", (e) => {
            e.preventDefault();
            canvasContainer.style.borderColor = "#28a745"; // Highlight the canvas when dragging
          });

          canvasContainer.addEventListener("dragleave", () => {
            canvasContainer.style.borderColor = "#007bff"; // Reset border color
          });

          canvasContainer.addEventListener("drop", (e) => {
            e.preventDefault();
            canvasContainer.style.borderColor = "#007bff";

            const imageUrl = e.dataTransfer.getData("text/plain"); // Get the image URL from drag

            // Add the image to the fabric.js canvas
            fabric.Image.fromURL(imageUrl, (img) => {
              img.scale(0.5); // Scale image
              img.set({
                left: e.offsetX - img.width / 2, // Position the image on the drop point
                top: e.offsetY - img.height / 2,
                hasControls: true, // Enable resize and controls
              });
              canvas.add(img); // Add the image to the canvas
            });
          });

        } else {
          const error = await response.json();
          throw new Error(error.error.message || error.error || "Unknown error occurred.");
        }
      } catch (err) {
        const errorMsg = document.createElement("p");
        errorMsg.textContent = `Error: ${err.message}`;
        resultDiv.appendChild(errorMsg);
      }
    });

  </script>

</html>